---
title: "Pydantic Data Validation"
date: 2024-12-12
draft: false
category: "python"
tags: ["python-knowhow", "pydantic", "validation", "api"]
---


Pydantic - Data validation using Python type hints.

---

## Installation

```bash
pip install pydantic

# With email validation
pip install 'pydantic[email]'

# With dotenv support
pip install 'pydantic[dotenv]'
```

---

## Basic Usage

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str
    age: int

# Valid data
user = User(id=1, name="Alice", email="alice@example.com", age=30)
print(user)
# id=1 name='Alice' email='alice@example.com' age=30

# Type coercion
user2 = User(id="2", name="Bob", email="bob@example.com", age="25")
print(user2.age, type(user2.age))  # 25 <class 'int'>

# Validation error
try:
    User(id="invalid", name="Charlie", email="charlie@example.com", age=30)
except Exception as e:
    print(e)
```

---

## Validators

```python
from pydantic import BaseModel, field_validator, model_validator

class User(BaseModel):
    name: str
    age: int
    email: str
    
    @field_validator('name')
    @classmethod
    def name_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip()
    
    @field_validator('age')
    @classmethod
    def age_must_be_positive(cls, v):
        if v < 0:
            raise ValueError('Age must be positive')
        if v > 150:
            raise ValueError('Age must be realistic')
        return v
    
    @field_validator('email')
    @classmethod
    def email_must_be_valid(cls, v):
        if '@' not in v:
            raise ValueError('Invalid email')
        return v.lower()
    
    @model_validator(mode='after')
    def check_adult_email(self):
        if self.age < 18 and 'work' in self.email:
            raise ValueError('Minors cannot have work email')
        return self

# Usage
user = User(name="  Alice  ", age=30, email="ALICE@EXAMPLE.COM")
print(user.name)   # "Alice" (trimmed)
print(user.email)  # "alice@example.com" (lowercased)
```

---

## Field Configuration

```python
from pydantic import BaseModel, Field

class Product(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    price: float = Field(..., gt=0, le=1000000)
    quantity: int = Field(default=0, ge=0)
    description: str = Field(default="", max_length=500)
    tags: list[str] = Field(default_factory=list)
    
    # Alias for JSON keys
    product_id: int = Field(..., alias="id")
    
    # Exclude from export
    internal_code: str = Field(default="", exclude=True)

# Usage
product = Product(
    id=1,
    name="Widget",
    price=19.99,
    quantity=100
)

print(product.model_dump())
# {'name': 'Widget', 'price': 19.99, 'quantity': 100, 'description': '', 'tags': [], 'product_id': 1}
```

---

## Nested Models

```python
from pydantic import BaseModel
from typing import List

class Address(BaseModel):
    street: str
    city: str
    country: str
    zip_code: str

class User(BaseModel):
    name: str
    email: str
    address: Address
    
class Company(BaseModel):
    name: str
    employees: List[User]

# Usage
company = Company(
    name="TechCorp",
    employees=[
        {
            "name": "Alice",
            "email": "alice@techcorp.com",
            "address": {
                "street": "123 Main St",
                "city": "Springfield",
                "country": "USA",
                "zip_code": "12345"
            }
        }
    ]
)

print(company.employees[0].address.city)  # Springfield
```

---

## JSON Serialization

```python
from pydantic import BaseModel
import json

class User(BaseModel):
    id: int
    name: str
    email: str

user = User(id=1, name="Alice", email="alice@example.com")

# To JSON string
json_str = user.model_dump_json()
print(json_str)
# {"id":1,"name":"Alice","email":"alice@example.com"}

# To dict
user_dict = user.model_dump()
print(user_dict)
# {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'}

# From JSON
user2 = User.model_validate_json(json_str)
print(user2)

# From dict
user3 = User.model_validate(user_dict)
print(user3)
```

---

## Optional and Union Types

```python
from pydantic import BaseModel
from typing import Optional, Union
from datetime import datetime

class Event(BaseModel):
    name: str
    date: datetime
    location: Optional[str] = None
    attendees: Union[int, str] = 0  # Can be int or str
    
event1 = Event(name="Conference", date="2024-12-12T10:00:00")
print(event1.location)  # None

event2 = Event(
    name="Meetup",
    date="2024-12-15T18:00:00",
    location="Downtown",
    attendees="50+"
)
print(event2.attendees)  # "50+"
```

---

## Custom Types

```python
from pydantic import BaseModel, field_validator
from typing import Annotated

# Custom validator as type
def validate_positive(v: int) -> int:
    if v <= 0:
        raise ValueError('Must be positive')
    return v

PositiveInt = Annotated[int, field_validator(validate_positive)]

class Product(BaseModel):
    name: str
    price: float
    quantity: int
    
    @field_validator('price', 'quantity')
    @classmethod
    def must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Must be positive')
        return v

product = Product(name="Widget", price=9.99, quantity=10)
```

---

## Settings Management

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "MyApp"
    debug: bool = False
    database_url: str
    api_key: str
    max_connections: int = 10
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

# .env file:
# DATABASE_URL=postgresql://localhost/mydb
# API_KEY=secret123
# DEBUG=true

settings = Settings()
print(settings.database_url)
print(settings.debug)  # True (from .env)
```

---

## API Response Models

```python
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class UserBase(BaseModel):
    email: str
    name: str

class UserCreate(UserBase):
    password: str

class UserResponse(UserBase):
    id: int
    created_at: datetime
    is_active: bool = True
    
    class Config:
        from_attributes = True  # For ORM models

class PaginatedResponse(BaseModel):
    items: List[UserResponse]
    total: int
    page: int
    page_size: int
    
    @property
    def total_pages(self) -> int:
        return (self.total + self.page_size - 1) // self.page_size

# Usage in FastAPI
# @app.post("/users/", response_model=UserResponse)
# def create_user(user: UserCreate):
#     ...
```

---

## Computed Fields

```python
from pydantic import BaseModel, computed_field

class Rectangle(BaseModel):
    width: float
    height: float
    
    @computed_field
    @property
    def area(self) -> float:
        return self.width * self.height
    
    @computed_field
    @property
    def perimeter(self) -> float:
        return 2 * (self.width + self.height)

rect = Rectangle(width=10, height=5)
print(rect.area)       # 50.0
print(rect.perimeter)  # 30.0

# Included in serialization
print(rect.model_dump())
# {'width': 10.0, 'height': 5.0, 'area': 50.0, 'perimeter': 30.0}
```

---

## Generic Models

```python
from pydantic import BaseModel
from typing import Generic, TypeVar, List

T = TypeVar('T')

class Response(BaseModel, Generic[T]):
    data: T
    message: str
    success: bool = True

class User(BaseModel):
    id: int
    name: str

# Usage
user_response = Response[User](
    data=User(id=1, name="Alice"),
    message="User retrieved successfully"
)

users_response = Response[List[User]](
    data=[
        User(id=1, name="Alice"),
        User(id=2, name="Bob")
    ],
    message="Users retrieved successfully"
)
```

---

## Discriminated Unions

```python
from pydantic import BaseModel, Field
from typing import Union, Literal

class Cat(BaseModel):
    pet_type: Literal["cat"]
    meow: str

class Dog(BaseModel):
    pet_type: Literal["dog"]
    bark: str

class Pet(BaseModel):
    animal: Union[Cat, Dog] = Field(..., discriminator="pet_type")

# Correct discrimination
cat_data = {"animal": {"pet_type": "cat", "meow": "meow"}}
pet = Pet(**cat_data)
print(pet.animal.meow)  # "meow"

dog_data = {"animal": {"pet_type": "dog", "bark": "woof"}}
pet2 = Pet(**dog_data)
print(pet2.animal.bark)  # "woof"
```

---

## FastAPI Integration

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import List

app = FastAPI()

class Item(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: str = Field(default="", max_length=500)
    price: float = Field(..., gt=0)
    tax: float = Field(default=0, ge=0)

class ItemResponse(Item):
    id: int

items_db: List[ItemResponse] = []

@app.post("/items/", response_model=ItemResponse)
def create_item(item: Item):
    item_response = ItemResponse(id=len(items_db) + 1, **item.model_dump())
    items_db.append(item_response)
    return item_response

@app.get("/items/", response_model=List[ItemResponse])
def list_items():
    return items_db

@app.get("/items/{item_id}", response_model=ItemResponse)
def get_item(item_id: int):
    for item in items_db:
        if item.id == item_id:
            return item
    raise HTTPException(status_code=404, detail="Item not found")
```

---

## Validation Context

```python
from pydantic import BaseModel, field_validator, ValidationInfo

class User(BaseModel):
    name: str
    role: str
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v, info: ValidationInfo):
        if info.context:
            min_length = info.context.get('min_name_length', 1)
            if len(v) < min_length:
                raise ValueError(f'Name must be at least {min_length} chars')
        return v

# With context
user = User.model_validate(
    {'name': 'Al', 'role': 'admin'},
    context={'min_name_length': 3}
)  # ValidationError!
```

---

## Performance Tips

```python
from pydantic import BaseModel, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(
        # Validate on assignment
        validate_assignment=True,
        
        # Use slots for memory efficiency
        use_enum_values=True,
        
        # Strict types (no coercion)
        strict=False,
        
        # Allow arbitrary types
        arbitrary_types_allowed=False,
    )
    
    name: str
    age: int

# Validate assignment
user = User(name="Alice", age=30)
user.age = 31  # Validated!
```

---