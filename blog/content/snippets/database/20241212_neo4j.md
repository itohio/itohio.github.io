---
title: "Neo4j Graph Database"
date: 2024-12-12
draft: false
category: "database"
tags: ["database-knowhow", "neo4j", "graph-db", "cypher"]
---


Neo4j graph database queries, algorithms, and vector search capabilities.

---

## Docker Setup

```yaml
version: '3.8'

services:
  neo4j:
    image: neo4j:5
    container_name: neo4j
    environment:
      NEO4J_AUTH: neo4j/password
      NEO4J_PLUGINS: '["apoc", "graph-data-science"]'
      NEO4J_dbms_security_procedures_unrestricted: apoc.*,gds.*
    volumes:
      - neo4j-data:/data
      - neo4j-logs:/logs
    ports:
      - "7474:7474"  # HTTP
      - "7687:7687"  # Bolt
    healthcheck:
      test: ["CMD-SHELL", "cypher-shell -u neo4j -p password 'RETURN 1'"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  neo4j-data:
  neo4j-logs:
```

```bash
# Start Neo4j
docker-compose up -d

# Access browser interface
# http://localhost:7474
# Username: neo4j
# Password: password
```

---

## Cypher Basics

### Create Nodes

```cypher
// Create single node
CREATE (p:Person {name: 'Alice', age: 30})

// Create multiple nodes
CREATE 
  (p1:Person {name: 'Bob', age: 35}),
  (p2:Person {name: 'Charlie', age: 28})

// Create with RETURN
CREATE (p:Person {name: 'David', age: 40})
RETURN p
```

### Create Relationships

```cypher
// Create nodes and relationship
CREATE (a:Person {name: 'Alice'})-[:KNOWS]->(b:Person {name: 'Bob'})

// Create relationship between existing nodes
MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Charlie'})
CREATE (a)-[:KNOWS {since: 2020}]->(b)

// Create with properties
CREATE (a:Person {name: 'Alice'})-[:WORKS_AT {role: 'Engineer', since: 2019}]->(c:Company {name: 'TechCorp'})
```

### Match (Query)

```cypher
// Match all nodes
MATCH (n) RETURN n

// Match by label
MATCH (p:Person) RETURN p

// Match by property
MATCH (p:Person {name: 'Alice'}) RETURN p

// Match with WHERE
MATCH (p:Person)
WHERE p.age > 30
RETURN p

// Match relationships
MATCH (p:Person)-[:KNOWS]->(friend)
RETURN p.name, friend.name

// Match with relationship properties
MATCH (p:Person)-[r:WORKS_AT]->(c:Company)
WHERE r.since > 2018
RETURN p.name, c.name, r.role

// Match patterns
MATCH (p:Person)-[:KNOWS]->(friend)-[:KNOWS]->(fof)
WHERE p.name = 'Alice'
RETURN fof.name AS friend_of_friend
```

### Update

```cypher
// Update property
MATCH (p:Person {name: 'Alice'})
SET p.age = 31
RETURN p

// Add property
MATCH (p:Person {name: 'Alice'})
SET p.email = 'alice@example.com'

// Remove property
MATCH (p:Person {name: 'Alice'})
REMOVE p.email

// Add label
MATCH (p:Person {name: 'Alice'})
SET p:Developer

// Update multiple properties
MATCH (p:Person {name: 'Alice'})
SET p += {age: 32, city: 'New York'}
```

### Delete

```cypher
// Delete node (must delete relationships first)
MATCH (p:Person {name: 'Alice'})
DELETE p

// Delete node and relationships
MATCH (p:Person {name: 'Alice'})
DETACH DELETE p

// Delete relationship
MATCH (p:Person)-[r:KNOWS]->(friend)
WHERE p.name = 'Alice'
DELETE r

// Delete all
MATCH (n)
DETACH DELETE n
```

---

## Advanced Queries

### Aggregation

```cypher
// Count
MATCH (p:Person)
RETURN count(p)

// Group by
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
RETURN c.name, count(p) AS employee_count

// Sum, avg, min, max
MATCH (p:Person)
RETURN 
  avg(p.age) AS avg_age,
  min(p.age) AS min_age,
  max(p.age) AS max_age
```

### Path Finding

```cypher
// Shortest path
MATCH path = shortestPath(
  (a:Person {name: 'Alice'})-[*]-(b:Person {name: 'David'})
)
RETURN path

// All shortest paths
MATCH path = allShortestPaths(
  (a:Person {name: 'Alice'})-[*]-(b:Person {name: 'David'})
)
RETURN path

// Path with max length
MATCH path = (a:Person {name: 'Alice'})-[*..3]-(b:Person)
RETURN path
```

### Collections

```cypher
// Collect results
MATCH (p:Person)-[:KNOWS]->(friend)
RETURN p.name, collect(friend.name) AS friends

// Unwind (expand list)
UNWIND [1, 2, 3] AS number
RETURN number

// List comprehension
MATCH (p:Person)
RETURN [x IN collect(p.age) WHERE x > 30] AS ages_over_30
```

---

## Graph Algorithms (GDS Library)

### PageRank

```cypher
// Create graph projection
CALL gds.graph.project(
  'myGraph',
  'Person',
  'KNOWS'
)

// Run PageRank
CALL gds.pageRank.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC

// Write results back
CALL gds.pageRank.write('myGraph', {
  writeProperty: 'pagerank'
})
```

### Community Detection (Louvain)

```cypher
// Detect communities
CALL gds.louvain.stream('myGraph')
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).name AS name, communityId
ORDER BY communityId

// Write communities
CALL gds.louvain.write('myGraph', {
  writeProperty: 'community'
})
```

### Centrality

```cypher
// Betweenness Centrality
CALL gds.betweenness.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC

// Degree Centrality
CALL gds.degree.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC

// Closeness Centrality
CALL gds.closeness.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC
```

### Similarity

```cypher
// Node Similarity
CALL gds.nodeSimilarity.stream('myGraph')
YIELD node1, node2, similarity
RETURN 
  gds.util.asNode(node1).name AS person1,
  gds.util.asNode(node2).name AS person2,
  similarity
ORDER BY similarity DESC
```

---

## Vector Search

### Setup Vector Index

```cypher
// Create vector index
CREATE VECTOR INDEX person_embeddings IF NOT EXISTS
FOR (p:Person)
ON p.embedding
OPTIONS {indexConfig: {
  `vector.dimensions`: 1536,
  `vector.similarity_function`: 'cosine'
}}

// Add embeddings to nodes
MATCH (p:Person {name: 'Alice'})
SET p.embedding = [0.1, 0.2, 0.3, ...]  // 1536 dimensions
```

### Vector Similarity Search

```cypher
// Find similar nodes
MATCH (p:Person)
WHERE p.embedding IS NOT NULL
WITH p, 
  gds.similarity.cosine(p.embedding, $queryEmbedding) AS similarity
WHERE similarity > 0.8
RETURN p.name, similarity
ORDER BY similarity DESC
LIMIT 10

// Using vector index (Neo4j 5.11+)
CALL db.index.vector.queryNodes(
  'person_embeddings',
  10,
  [0.1, 0.2, 0.3, ...]  // Query vector
)
YIELD node, score
RETURN node.name, score
```

### Hybrid Search (Vector + Filters)

```cypher
// Vector search with filters
CALL db.index.vector.queryNodes(
  'person_embeddings',
  100,
  $queryEmbedding
)
YIELD node, score
WHERE node.age > 25 AND node.city = 'New York'
RETURN node.name, node.age, score
ORDER BY score DESC
LIMIT 10
```

---

## Python Integration

```python
from neo4j import GraphDatabase
import numpy as np

class Neo4jConnection:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
    
    def close(self):
        self.driver.close()
    
    def query(self, query, parameters=None):
        with self.driver.session() as session:
            result = session.run(query, parameters)
            return [record.data() for record in result]
    
    def create_person(self, name, age):
        query = """
        CREATE (p:Person {name: $name, age: $age})
        RETURN p
        """
        return self.query(query, {'name': name, 'age': age})
    
    def create_relationship(self, person1, person2, rel_type):
        query = f"""
        MATCH (a:Person {{name: $person1}})
        MATCH (b:Person {{name: $person2}})
        CREATE (a)-[r:{rel_type}]->(b)
        RETURN r
        """
        return self.query(query, {'person1': person1, 'person2': person2})
    
    def find_friends(self, name):
        query = """
        MATCH (p:Person {name: $name})-[:KNOWS]->(friend)
        RETURN friend.name AS name, friend.age AS age
        """
        return self.query(query, {'name': name})
    
    def add_embedding(self, name, embedding):
        """Add vector embedding to person"""
        query = """
        MATCH (p:Person {name: $name})
        SET p.embedding = $embedding
        RETURN p
        """
        return self.query(query, {'name': name, 'embedding': embedding})
    
    def vector_search(self, query_embedding, limit=10):
        """Search by vector similarity"""
        query = """
        MATCH (p:Person)
        WHERE p.embedding IS NOT NULL
        WITH p, 
          reduce(dot = 0.0, i IN range(0, size(p.embedding)-1) | 
            dot + p.embedding[i] * $query[i]
          ) AS similarity
        RETURN p.name, similarity
        ORDER BY similarity DESC
        LIMIT $limit
        """
        return self.query(query, {'query': query_embedding, 'limit': limit})

# Usage
conn = Neo4jConnection('bolt://localhost:7687', 'neo4j', 'password')

# Create nodes
conn.create_person('Alice', 30)
conn.create_person('Bob', 35)

# Create relationship
conn.create_relationship('Alice', 'Bob', 'KNOWS')

# Query
friends = conn.find_friends('Alice')
print(friends)

# Add embeddings (from OpenAI or similar)
embedding = np.random.rand(1536).tolist()
conn.add_embedding('Alice', embedding)

# Vector search
results = conn.vector_search(embedding)
print(results)

conn.close()
```

---

## Indexes

```cypher
// Create index
CREATE INDEX person_name IF NOT EXISTS FOR (p:Person) ON (p.name)

// Composite index
CREATE INDEX person_name_age IF NOT EXISTS FOR (p:Person) ON (p.name, p.age)

// Full-text index
CREATE FULLTEXT INDEX person_search IF NOT EXISTS
FOR (p:Person) ON EACH [p.name, p.bio]

// Use full-text search
CALL db.index.fulltext.queryNodes('person_search', 'alice developer')
YIELD node, score
RETURN node.name, score

// List indexes
SHOW INDEXES

// Drop index
DROP INDEX person_name
```

---

## Performance

```cypher
// Explain query
EXPLAIN
MATCH (p:Person)-[:KNOWS]->(friend)
WHERE p.name = 'Alice'
RETURN friend.name

// Profile query (with execution stats)
PROFILE
MATCH (p:Person)-[:KNOWS]->(friend)
WHERE p.name = 'Alice'
RETURN friend.name

// Show query plan
CALL dbms.listQueries()
```

---